Carlos Carrillo-Calderon10/17/2016OSU-CS362Assignment 4Answer the following questions and put the answers in submissions/hw4/P2.txt1)	Explore your Cobertura site and find a branch (for/if) that has been 'covered' (a hit count of greater than zero on the left column near the line number) but is highlighted red. What does this indicate?I found the following branch: (green)  78	(red)   1	 (red highlight)  if(score > 21) { (green)  79	(red)   0	 (red highlight)       return -1; (green)  80	(green) 1 }First, we need to know that the first column is the line number in the source file.  It is never red, and it is green only if there is some executable code on it. Second, we need to know that the second column line is green when the line and all conditionals on the line are covered. Otherwise, it is red, which is the case we see above in lines 78 and 79. Thus, what the red-color highlight in these lines mean is that the “if statement” gets executed, however the statement is never >21. Additionally, the number in the second column tells the number of times the line is executed. In this case, we can see that line 78 is executed 1 time and line 79 is never executed since there is a zero on that line.2)	Why are Java interfaces always marked with N/A for coverage?According to my research, it seems that there is a plugin missing when running the test within the Maven environment. This plugin provides the features of Cobertura within the Maven 2 & 3 environment. The report generated by this plugin is the result of executing the Cobertura tool against your compiled classes to help you determine how well the unit testing and integration testing efforts have been, and can then be used to identify which parts of your Java program are lacking test coverage. Info taken from: “http://www.mojohaus.org/cobertura-maven-plugin/”3)	From a testing and debugging perspective, what is the disadvantage of a functional test liketestBasicFunctionality?Although there are a number of benefits when you employ functional testing, there are also many disadvantages to this test as well. For example:•	The possibility to omit logical mistakes in software; •	The probability of redundant testing. •	Functional testing cannot verify that all the paths in the software are working properly. •	Development time: With test-driven development this is already calculated in for unit tests, but you still need integration and system tests, which may need automation code as well. Code written once is usually tested on several later stages.•	Skill level: of course, the tools have to be supported. But it's not only your own team. In larger project you may have a separate testing team that writes tests for checking the interfaces between your team's product and other's. So many more people have to have more knowledge.•	Tooling needs: you're spot on there. Not much to add to this.•	Failed tests: This is the real bugger (for me anyways). There's a bunch of different reasons, each of which can be seen as a disadvantage. And the biggest disadvantage is the time required to decide which of these reasons actually applies to your failed test.	• failed, because of an actual bug. (just for completeness, as this is of course advantageous)	• failed, because your test code has been written with a traditional bug.	• failed, because your test code has been written for an older version of your product and is no longer compatible	• failed, because the requirements have changed and the tested behavior is now deemed 'correct'•	Non-failed tests: These are a disadvantage too and can be quite bad. It happens mostly, when you change things and comes close to what Adam answered. If you change something in your product's code, but the test doesn't account for it at all, then it gives you this "false sense of security".
•	An important aspect of non-failed tests is that a change of requirements can lead earlier behavior to become invalid. If you have decent traceability, the requirement change should be able to be matched to your test code and you know you can no longer trust that test. Of course, maintaining this traceability is yet another disadvantages. And if you don't, you end up with a test that does not fail, but actually verifies that your product works wrongly. Somewhere down the road this will hit you, usually when/where you least expect it.•	Additional deployment costs: You do not just run unit-tests as a developer on your own machine. With automated tests, you want to execute them on commits from others at some central place to find out when someone broke your work. This is nice, but also needs to be set up and maintained.4)	Describe the relationship, if any, between the number of if/else statements in a piece of code and the number of branches to be covered.Each if or else statement represents a branch to be covered in Cobertura. At a more basic level, an if/else statement alone can be tested using a Line Coverage approach as part of one of the statements a particular branch can have. At the same time, an if/else statement can be tested using a Branch Coverage approach, which checks if the program took the true and false branch for each conditional (if, while, for). Thus, there are twice as many branches as conditionals.